# 演習1

## 1. 商品分類別に、販売単価の安い順で並べたランキング表を作る

```sql
SELECT 商品名, 商品分類, 販売単価,
       RANK () OVER (PARTITION BY 商品分類
                         ORDER BY 販売単価) AS ランキング FROM 商品;
```

- 商品分類のグループごとで販売単価によるランク付け
- 出力結果:

```log
     商品名     |   商品分類   | 販売単価 | ランキング
----------------+--------------+----------+------------
 フォーク       | キッチン用品 |      500 |          1
 おろしがね     | キッチン用品 |      880 |          2
 包丁           | キッチン用品 |     3000 |          3
 圧力鍋         | キッチン用品 |     6800 |          4
 ボールペン     | 事務用品     |      100 |          1
 穴あけパンチ   | 事務用品     |      500 |          2
 Tシャツ        | 衣服         |     1000 |          1
 カッターシャツ | 衣服         |     4000 |          2
```

## 2. PARTITIONBYを指定しない場合

```sql
SELECT 商品名, 商品分類, 販売単価,
       RANK () OVER (ORDER BY 販売単価) AS ランキング
  FROM 商品;
```

- 販売単価でランク付け
- 出力結果:

```log
     商品名     |   商品分類   | 販売単価 | ランキング
----------------+--------------+----------+------------
 ボールペン     | 事務用品     |      100 |          1
 フォーク       | キッチン用品 |      500 |          2
 穴あけパンチ   | 事務用品     |      500 |          2
 おろしがね     | キッチン用品 |      880 |          4
 Tシャツ        | 衣服         |     1000 |          5
 包丁           | キッチン用品 |     3000 |          6
 カッターシャツ | 衣服         |     4000 |          7
 圧力鍋         | キッチン用品 |     6800 |          8
```

## 3. RANK、DENSE_RANK、ROW_NUMBERの結果を比較

```sql
SELECT 商品名, 商品分類, 販売単価,
       RANK () OVER (ORDER BY 販売単価) AS RANK,
       DENSE_RANK () OVER (ORDER BY 販売単価) AS DENSE_RANK,
       ROW_NUMBER () OVER (ORDER BY 販売単価) AS ROW_NUMBER
  FROM 商品;
```

- 出力結果:

```log
     商品名     |   商品分類   | 販売単価 | rank | dense_rank | row_number
----------------+--------------+----------+------+------------+------------
 ボールペン     | 事務用品     |      100 |    1 |          1 |          1
 フォーク       | キッチン用品 |      500 |    2 |          2 |          2
 穴あけパンチ   | 事務用品     |      500 |    2 |          2 |          3
 おろしがね     | キッチン用品 |      880 |    4 |          3 |          4
 Tシャツ        | 衣服         |     1000 |    5 |          4 |          5
 包丁           | キッチン用品 |     3000 |    6 |          5 |          6
 カッターシャツ | 衣服         |     4000 |    7 |          6 |          7
 圧力鍋         | キッチン用品 |     6800 |    8 |          7 |          8
(8 rows)
```

## 4. SUM関数をウィンドウ関数として使う

```sql
SELECT 商品ID, 商品名, 販売単価,
       SUM (販売単価) OVER (ORDER BY 商品ID) AS 累計
  FROM 商品;
```

- 出力結果:

```log
 商品id |     商品名     | 販売単価 | 累計
--------+----------------+----------+-------
 0001   | Tシャツ        |     1000 |  1000
 0002   | 穴あけパンチ   |      500 |  1500
 0003   | カッターシャツ |     4000 |  5500
 0004   | 包丁           |     3000 |  8500
 0005   | 圧力鍋         |     6800 | 15300
 0006   | フォーク       |      500 | 15800
 0007   | おろしがね     |      880 | 16680
 0008   | ボールペン     |      100 | 16780
(8 rows)
```

## 5. 集計対象のレコードを「直近の3行」にする

```sql
SELECT 商品ID, 商品名, 販売単価,
       AVG (販売単価) OVER (ORDER BY 商品ID
                                ROWS 2 PRECEDING) AS 移動平均
  FROM 商品;
```

- 直前の2つの行の平均（例: 包丁は穴あけパンチとカッターシャツの3つの平均となる）
- 出力結果:

```log
 商品id |     商品名     | 販売単価 |       移動平均
--------+----------------+----------+-----------------------
 0001   | Tシャツ        |     1000 | 1000.0000000000000000
 0002   | 穴あけパンチ   |      500 |  750.0000000000000000
 0003   | カッターシャツ |     4000 | 1833.3333333333333333
 0004   | 包丁           |     3000 | 2500.0000000000000000
 0005   | 圧力鍋         |     6800 | 4600.0000000000000000
 0006   | フォーク       |      500 | 3433.3333333333333333
 0007   | おろしがね     |      880 | 2726.6666666666666667
 0008   | ボールペン     |      100 |  493.3333333333333333
```

## 6. 文末のORDERBY句によって結果の並び順が保証される

```sql
-- List8-8 このSELECT文の結果の並び順は保証されない

SELECT 商品ID, 商品名, 販売単価,
       RANK () OVER (ORDER BY 販売単価) AS ランキング
  FROM 商品;

-- List8-9 文末のORDER BY句によって結果の並び順が保証される

SELECT 商品名, 商品分類, 販売単価,
       RANK () OVER (ORDER BY 販売単価) AS ランキング
  FROM 商品
 ORDER BY ランキング;
```
