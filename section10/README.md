# 10回目

## リレーショナル代数

- 集合演算
  - 和集合演算: union
  - 差集合演算: difference
  - 共通集合演算: intersection
  - 直積演算: direct product
- 関係演算
  - 射形演算: projection
  - 選択演算: selection
  - 結合演算: join
  - 商演算: division

## 3層スキーマ

- 論理スキーマ
  - 現実世界の論理的なモデルで、対象世界全体を記述
- 外部スキーマ
  - アプリケーションプログラムまたはエンドユーザーが使用するデータを記述
  - 論理スキーマとの間の変換操作によって、論理的データ独立性を実現
- 内部スキーマ
  - コンピュータ内部での物理的なデータの格納方法を記述
  - 論理スキーマとの間の変換操作によって、物理的データ独立性を実現

### データ独立性

- 論理的データ独立性
  - データベースの論理的な構造（実際のテーブル構成）をしらなくてもアプリケーションプログラムを作成できる。データ操作を実行できる。
  - アプリケーションプログラムを書きやすい、またはエンドユーザーが操作しやすい形式でデータを提供できる。
  - SQLで記述されたプログラムは、その後にテーブルの統合・分解、カラムの追加等があっても、ビューをうまく定義してやれば、変更する必要がない。
- 物理的データ独立性
  - データベースの物理的な構造（実際のファイル構成）を性能や運用性を考慮して最適化できる。
  - SQLで記述されたプログラムは、その後にインデックスの追加・削除、テーブルの分散配置等があっても、何も変更する必要がない。

## インデックス

- what index
  - テーブルへのアクセスを高速化するためのデータ構造
  - テーブルの任意の列（単一、複数列）に対して作成することにより、ランダムアクセスやキー順アクセスを効率化
  - インデックス作成のデメリット: 記憶スペースと更新処理のオーバーヘッドの増加
- 作成方法
  - `create index`で作成、`drop index`で削除
  - 主キーに指定した列にはシステムが自動的にインデックスを作成

### 代表的なインデックス

|     種類     |                                ハッシュ                                |                               ISAM                                |                                     B+木                                      |
| :----------: | :--------------------------------------------------------------------: | :---------------------------------------------------------------: | :---------------------------------------------------------------------------: |
|  データ構造  |            キー値をハッシュ関数で数値化して分散配置した構造            |              キー値を1次元配列に値順に整列させた構造              |                 キー値を多分岐かつ平衡の探索木に格納した構造                  |
| アルゴリズム |                                ハッシュ                                |                             二分探索                              |                                    探索木                                     |
|   記憶効率   |                                  高い                                  |           低い（データの挿入・削除が繰り返された場合）            |                                   やや低い                                    |
|   検索効率   | 高速（理想状態では、データ量に非依存）。ただしランダムアクセスのみ可能 | 高速（検索時間は$log_N$に比例）。ランダム、キー順の両アクセス有効 | 高速（検索時間は$log_N$に比例）かつ安定的。ランダム、キー順の両アクセスに有効 |
|   更新効率   |                                  高速                                  |                             やや低速                              |                                     低速                                      |

```sql
create [unique] index indexName on tableName [using type]
```

- 列名は複数指定可能
- オプションに一意指定(UNIQUE)、降順指定(DESC)などがある
- 検索実行時にインデックスをしようするかどうかは、システムが自動的に決定
- ユーザーは`explain`でインデックスを使用されるかどうかをチェック可能

## B+木

- N分木（2<=N）であり、木の高さ（根ノードから葉ノードまでの距離）は、木のどの部分でも等しい
- 各ノードには、最大N個のポインタと最大N-1個のキー値を格納でき、キー値は昇順に格納
- 根ノードは、自身が葉ノード出ない限り、中間ノードへのポインタを持つ
- 中間ノードは、最小N/2個の葉ノードへのポインタとポインタ数より1少ない個数のキー値を持つ
- 葉ノードは、最小N/2-1個のタプルへのポインタ、1個の次の葉ノードへのポインタとタプルへのポインタ数と同じ個数のキーを持つ
